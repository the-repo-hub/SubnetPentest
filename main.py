import socket
import threading
import time
from typing import List

import requests
from bs4 import BeautifulSoup
from threading import Thread
import datetime


class Backend:
    ua = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'
    }
    timeout = 10
    port = 1723
    threads = 300
    ip_count = 0
    name = None

    @classmethod
    def host_check(cls, host):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(cls.timeout)
        result = sock.connect_ex((host, cls.port))
        if result == 0:
            with open(f'{cls.name}.txt', 'a') as file:
                file.write(host + '\n')
        sock.close()

    @classmethod
    def calculate_ip_in_range(cls, ip_range) -> int:
        ip_start, ip_end = ip_range.split('-')
        a1, b1, c1, d1 = map(int, ip_start.split('.'))
        a2, b2, c2, d2 = map(int, ip_end.split('.'))
        result = 255 * 3 * (a2 - a1) + 255 * 2 * (b2 - b1) + 255 * (c2 - c1) + d2 - d1
        return result

    @classmethod
    def filter_ipv4(cls, ip_ranges: List[str]) -> List[str]:
        for num, ip_range in enumerate(ip_ranges):
            if ':' in ip_range:
                return ip_ranges[:num]
            cls.ip_count += cls.calculate_ip_in_range(ip_range)
        return ip_ranges

    @classmethod
    def get_ip_pull(cls, url: str) -> List[str]:
        response = requests.get(url, headers=cls.ua)
        text = BeautifulSoup(response.text, 'html.parser').find('pre').text
        cls.name = BeautifulSoup(response.text, 'html.parser').find('article').find('h2').text
        return cls.filter_ipv4(text.split('\n')[:-1])

    @classmethod
    def convert_range_to_ip(cls, ip_range: str):
        ip_start, ip_end = ip_range.split('-')
        a1, b1, c1, d1 = map(int, ip_start.split('.'))
        a2, b2, c2, d2 = map(int, ip_end.split('.'))
        for a in range(a1, a2 + 1):
            for b in range(b1, b2 + 1):
                for c in range(c1, c2 + 1):
                    for d in range(d1 + 1, d2 + 1):
                        yield '{}.{}.{}.{}'.format(a, b, c, d)

    @classmethod
    def run(cls):
        pull = cls.get_ip_pull('https://suip.biz/?act=all-country-ip&province=Gabrovo&all')
        start = datetime.datetime.now()
        # FIXME make a formula, because this one will calculate with 300 threads
        estimated_seconds = cls.ip_count // 34
        print(
            f'Ip quantity: {cls.ip_count}\nWill end at:{start + datetime.timedelta(seconds=estimated_seconds)}\nEstimated seconds: {estimated_seconds}')
        for ip_range in pull:
            for ip in cls.convert_range_to_ip(ip_range):
                cls.ip_count -= 1
                print(cls.ip_count)
                while threading.active_count() >= cls.threads:
                    time.sleep(0.1)
                Thread(target=cls.host_check, args=(ip,)).start()
        print(
            f'started at: {start}\nended at: {datetime.datetime.now()}\nestimated:{datetime.datetime.now() - start}'
        )


Backend.run()
