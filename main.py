import ipaddress
import re
import socket
import sys
import threading
import time
from ipaddress import IPv4Network
from threading import Thread
from typing import List
from typing import Type
import subprocess
from PyQt5.QtWidgets import QApplication, QDialog
from PyQt5.QtWidgets import QTableWidgetItem, QMainWindow
from PyQt5.uic import loadUi


class MainMenu(QMainWindow):
    def __init__(self):
        super().__init__()
        loadUi('main.ui', self)
        self.scan_thread = Type[threading.Thread]
        self.hosts_popup = HostsPopup(self)
        self.ports_popup = PortsPopup(self)
        self.setWindowTitle('SubnetPentest')
        self.hostsBtn.clicked.connect(self.hosts_popup.show)
        self.portsBtn.clicked.connect(self.ports_popup.show)
        self.scanBtn.clicked.connect(self.scan_start)
        self.modulesCheckbox.stateChanged.connect(self.modules_onclick)
        self.show()

    def scan_start(self):
        self.scan_thread = threading.Thread(target=Backend.run, args=(self,))
        self.scan_thread.start()
        self.scanBtn.clicked.disconnect(self.scan_start)
        self.scanBtn.clicked.connect(self.scan_stop)
        self.scanBtn.setText('Stop')

    def scan_stop(self):
        self.scanBtn.setEnabled(False)
        Backend.stop_event.set()
        self.scanBtn.clicked.disconnect(self.scan_stop)
        self.scanBtn.clicked.connect(self.scan_start)
        self.scanBtn.setText('Start')

    def switch_scan_btn_state(self):
        if self.hostsList.count() > 0 and self.portsList.count() > 0:
            self.scanBtn.setEnabled(True)
        else:
            self.scanBtn.setEnabled(False)

    def modules_onclick(self, state):
        if state == 2:
            self.vulnersList.setEnabled(True)
            self.vulnerBtn.setEnabled(True)
        else:
            self.vulnersList.setEnabled(False)
            self.vulnerBtn.setEnabled(False)


class HostsPopup(QDialog):

    def __init__(self, main_menu):
        super().__init__()
        self.main_menu = main_menu
        loadUi('addHosts.ui', self)
        self.saveBtn.clicked.connect(self.save)

    def save(self):
        lines = []
        quantity = 0
        # TODO move it to backend
        for num, line in enumerate(self.hostsEdit.toPlainText().split(), start=1):
            if Backend.host_pattern.match(line):
                quantity += 1
                lines.append((ipaddress.IPv4Address(line),))
            elif Backend.host_range_pattern.match(line):
                start, end = map(ipaddress.IPv4Address, line.split('-'))
                gen = ipaddress.summarize_address_range(start, end)
                for network in gen:
                    quantity += network.num_addresses
                    lines.append(network)
            elif Backend.host_cidr_pattern.match(line):
                network = ipaddress.ip_network(line, strict=False)
                quantity += network.num_addresses
                lines.append(network)
            else:
                self.label.setText(f'Error in line {num}')
                return None
        Backend.lines = lines
        self.main_menu.quantityLabel.setText(str(quantity))
        self.main_menu.hostsList.clear()
        self.main_menu.hostsList.addItems(self.hostsEdit.toPlainText().split())
        self.main_menu.switch_scan_btn_state()
        self.close()


class PortsPopup(QDialog):

    def __init__(self, main_menu: MainMenu):
        super().__init__()
        self.main_menu = main_menu
        loadUi('addPorts.ui', self)
        self.saveBtn.clicked.connect(self.save)

    def save(self):
        ports = self.portsEdit.toPlainText().split()
        for num, port in enumerate(ports, start=1):
            if not Backend.port_pattern.match(port):
                self.label.setText(f'Error in line {num}')
                return None
        Backend.ports = ports
        self.main_menu.portsList.clear()
        self.main_menu.portsList.addItems(Backend.ports)
        self.main_menu.switch_scan_btn_state()
        self.close()


class Backend:
    host_pattern = re.compile(r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_range_pattern = re.compile(
        r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)-((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_cidr_pattern = re.compile(
        r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)/([0-9]|[1-2][0-9]|3[0-2])$')
    port_pattern = re.compile(r'^([1-9]\d{0,3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$')
    lines: List[IPv4Network] = []
    ports: List[str] = []
    stop_event = threading.Event()
    threads_orig = threading.active_count()

    @classmethod
    def _host_check(cls, host: str, port: int, frontend: MainMenu) -> None:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(frontend.timeout.value())
        table = frontend.tableWidget
        result = sock.connect_ex((host, port))
        if result == 0:
            current_row = table.rowCount()
            table.insertRow(current_row)
            table.setItem(current_row, 0, QTableWidgetItem(host))
            table.setItem(current_row, 1, QTableWidgetItem(str(port)))
        sock.close()

    @classmethod
    def _stop_run(cls, frontend: MainMenu):
        while threading.active_count() > cls.threads_orig + 1:
            frontend.currentHost.setText(f'Wait for stop {threading.active_count() - cls.threads_orig} threads')
            time.sleep(0.2)
        frontend.currentHost.setText('Done!')
        frontend.scanBtn.clicked.connect(frontend.scan_start)
        frontend.scanBtn.setText('Scan')
        cls.stop_event = threading.Event()
        frontend.scanBtn.setEnabled(True)

    @classmethod
    def vpn_connect(cls, host, user, password):
        # FIXME rewrite it
        cmd = [
            "pon",
            "your-ppp-connection-name",
            "user", user,
            "password", password,
            "remotename", host,
        ]
        process = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if process.returncode == 0:
            print("Connected to PPTP VPN successfully")
        else:
            print("Failed to connect to PPTP VPN")
            print("Error output:", process.stderr.decode())

    @classmethod
    def run(cls, frontend: MainMenu) -> None:
        done_quantity = 0
        for line in cls.lines:
            for host in line:
                for port in cls.ports:
                    if cls.stop_event.is_set():
                        return cls._stop_run(frontend)
                    frontend.currentHost.setText('Current host: {host}:{port}'.format(host=host, port=port))
                    while threading.active_count() >= frontend.threads.value() + cls.threads_orig:
                        time.sleep(0.1)
                    Thread(target=cls._host_check, args=(str(host), int(port), frontend)).start()
                    done_quantity += 1
            frontend.progressBar.setValue(done_quantity * 100 // int(frontend.quantityLabel.text()))
        return cls._stop_run(frontend)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    m = MainMenu()
    sys.exit(app.exec_())
