import re
import socket
import threading
import time
from ipaddress import IPv4Network
from typing import List, Type

from PyQt5.QtWidgets import QMainWindow, QTableWidgetItem
from sqlalchemy import or_

from base import HostsDataTable, base_session
from consts import TableColumnsConsts


class Backend:
    host_pattern = re.compile(r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_range_pattern = re.compile(
        r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)-((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_cidr_pattern = re.compile(
        r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)/([0-9]|[1-2][0-9]|3[0-2])$')
    port_pattern = re.compile(r'^([1-9]\d{0,3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$')

    ip_networks: List[IPv4Network] = []
    ports: List[str] = []

    scan_stop_event = threading.Event()
    threads_orig = threading.active_count()

    frontend = Type[QMainWindow]

    save_stop_event = threading.Event()

    base_queue: List[HostsDataTable] = []

    @classmethod
    def table_save_worker(cls):
        while not cls.save_stop_event.is_set():
            time.sleep(5)
            if cls.base_queue:
                length = len(cls.base_queue)
                for i in range(length):
                    cls.add_or_edit_data_to_base(cls.base_queue[i])
                base_session.commit()
                cls.base_queue = cls.base_queue[length:]
        cls.save_stop_event = threading.Event()

    @classmethod
    def add_or_edit_data_to_base(cls, data: HostsDataTable):
        expression = or_(HostsDataTable.host == data.host, HostsDataTable == data.port)
        host = base_session.query(HostsDataTable).filter(expression).first()
        if host and data.username and data.password:
            host.username = data.username
            host.password = data.password
        elif not host:
            base_session.add(data)

    @classmethod
    def _host_check(cls, host: str, port: int) -> None:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(cls.frontend.timeout.value())
        table = cls.frontend.tableWidget
        result = sock.connect_ex((host, port))
        if result == 0:
            current_row = table.rowCount()
            table.insertRow(current_row)
            table.setItem(current_row, TableColumnsConsts.host.value, QTableWidgetItem(host))
            table.setItem(current_row, TableColumnsConsts.port.value, QTableWidgetItem(str(port)))
            cls.base_queue.append(HostsDataTable(host=host, port=port))
        sock.close()

    @classmethod
    def stop_run(cls):
        while threading.active_count() > cls.threads_orig + 2:
            cls.frontend.currentHost.setText(f'Wait for stop {threading.active_count() - cls.threads_orig} threads')
            time.sleep(0.2)
        cls.frontend.currentHost.setText('Done!')
        cls.frontend.scanBtn.clicked.connect(cls.frontend.scan_start)
        cls.frontend.scanBtn.setText('Scan')
        cls.scan_stop_event = threading.Event()
        cls.frontend.scanBtn.setEnabled(True)
        cls.save_stop_event.set()

    @classmethod
    def run(cls) -> None:
        threading.Thread(target=cls.table_save_worker).start()
        done_quantity = 0
        for network in cls.ip_networks:
            for host in network:
                for port in cls.ports:
                    if cls.scan_stop_event.is_set():
                        return cls.stop_run()
                    cls.frontend.currentHost.setText('Current host: {host}:{port}'.format(host=host, port=port))
                    while threading.active_count() >= cls.frontend.threads.value() + cls.threads_orig:
                        time.sleep(0.1)
                    threading.Thread(target=cls._host_check, args=(str(host), int(port))).start()
                    done_quantity += 1
            percent = done_quantity * 100 // (int(cls.frontend.quantityLabel.text()) * len(cls.ports))
            print(percent, '%', sep='')
            # TODO progressBar exits program (sigsegv)
            #cls.frontend.progressBar.setValue(percent)
        return cls.stop_run()
