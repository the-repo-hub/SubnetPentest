import ipaddress
import re
import socket
import threading
import time
from typing import List, Type, Union

from PyQt5.QtWidgets import QMainWindow

from database import HostsDataTable, base_session
from vpn_brute import PPTPBrute
from consts import FrontendNames

# 1. Scan method (Backend.run)
# 2. Queue worker
# 3. Progress bar worker

CUSTOM_WORKERS = 3


class Backend:
    host_pattern = re.compile(r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_range_pattern = re.compile(
        r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)-((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$'
    )
    host_cidr_pattern = re.compile(
        r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)/([0-9]|[1-2][0-9]|3[0-2])$'
    )
    port_pattern = re.compile(r'^([1-9]\d{0,3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$')

    ip_networks_lines: List[Union[ipaddress.IPv4Network, str]] = []
    ports: List[str] = []

    scan_stop_event = threading.Event()
    threads_orig = threading.active_count()

    frontend = Type[QMainWindow]

    base_queue: List[HostsDataTable] = []
    done_quantity = 0
    _queue_worker_thread: threading.Thread = None
    # _progress_bar_worker_thread: threading.Thread = None
    _delay = 0.2

    @classmethod
    def ip_networks(cls) -> str:
        for line in cls.ip_networks_lines:
            if isinstance(line, ipaddress.IPv4Network):
                for host in line:
                    yield str(host)
            else:
                yield line

    @classmethod
    def set_ip_networks(cls, network_lines: List[str]) -> None:
        quantity = 0
        cls.ip_networks_lines.clear()
        for num, line in enumerate(network_lines, start=1):
            if Backend.host_pattern.match(line):
                quantity += 1
                cls.ip_networks_lines.append(line)
            elif Backend.host_range_pattern.match(line):
                start, end = map(ipaddress.IPv4Address, line.split('-'))
                network = next(ipaddress.summarize_address_range(start, end))
                quantity += network.num_addresses
                cls.ip_networks_lines.append(network)
            elif Backend.host_cidr_pattern.match(line):
                network = ipaddress.ip_network(line, strict=False)
                quantity += network.num_addresses
                cls.ip_networks_lines.append(network)
            else:
                cls.frontend.warning_label.setText(f'Error in line {num}')
                Backend.ip_networks_lines.clear()
                return None
        cls.frontend.quantityLabel.setText(str(quantity))

    @classmethod
    def _queue_save_worker(cls) -> None:
        while not cls.scan_stop_event.is_set():
            time.sleep(5)
            if cls.base_queue:
                length = len(cls.base_queue)
                for i in range(length):
                    cls.base_queue[i].add_or_edit_data_to_base()
                base_session.commit()
                cls.base_queue = cls.base_queue[length:]

    @classmethod
    def _progress_bar_worker(cls, all_ips_quantity: int, ports_length: int) -> None:
        while not cls.scan_stop_event.is_set():
            time.sleep(2)
            percent = cls.done_quantity * 100 // (all_ips_quantity * ports_length)
            if percent != int(cls.frontend.progressBar.value()):
                cls.frontend.progressBar.setValue(percent)
        cls.done_quantity = 0

    @classmethod
    def _host_check(cls, host: str, port: int) -> None:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(cls.frontend.timeout_spin.value())
        start = time.time()
        result = sock.connect_ex((host, port))
        end = round(time.time() - start, 3)
        if result == 0:
            cls.frontend.add_line_at_table(host=host, time_s=str(end), port=str(port))
            cls.base_queue.append(HostsDataTable(host=host, port=port))
        return sock.close()

    @classmethod
    def _stop_run(cls) -> None:
        # we need to wait workers
        while threading.active_count() > cls.threads_orig + CUSTOM_WORKERS:
            cls.frontend.currentHost_label.setText(
                f'Wait for stop {threading.active_count() - cls.threads_orig} threads'
            )
            time.sleep(cls._delay)
        cls._queue_worker_thread.join()
        # cls._progress_bar_worker_thread.join()
        # Renew events
        cls.scan_stop_event = threading.Event()

        # Enable modules, scans, etc
        cls.frontend.scanBtn.setEnabled(True)
        cls.frontend.pptpBtn.setEnabled(True)
        cls.frontend.modulesCheckbox.setEnabled(True)

        # Return button functionality
        cls.frontend.scanBtn.clicked.disconnect(cls.frontend.scan_stop)
        cls.frontend.scanBtn.clicked.connect(cls.frontend.scan_start)
        cls.frontend.currentHost_label.setText(FrontendNames.done)
        cls.frontend.scanBtn.setText(FrontendNames.scan)

    @classmethod
    def _stop_pptp_run(cls) -> None:
        # cls._progress_bar_worker_thread.join()
        cls.scan_stop_event = threading.Event()
        cls.frontend.modulesCheckbox.setEnabled(True)
        cls.frontend.set_ports_status(True)
        cls.frontend.set_hosts_status(True)
        cls.frontend.pptpBtn.clicked.disconnect(cls.frontend.stop_pptp_scan)
        cls.frontend.pptpBtn.clicked.connect(cls.frontend.pptp_popup.show)
        cls.frontend.pptpBtn.setEnabled(True)
        cls.frontend.pptpBtn.setText(FrontendNames.pptp_scan)
        cls.frontend.currentHost_label.setText(FrontendNames.done)

    @classmethod
    def run_pptp_scan(cls, hosts: List[str]) -> None:
        credentials = open('credentials.txt').read().split('\n')
        # cls._progress_bar_worker_thread = threading.Thread(target=cls._progress_bar_worker, args=(len(hosts), 1))
        # cls._progress_bar_worker_thread.start()
        for host in hosts:
            for pair in credentials:
                login, password = pair.split(':')
                cls.frontend.currentHost_label.setText(f'{host} {pair}')
                start = time.time()
                result = PPTPBrute.connect_attempt(host=host, login=login, password=password)
                end = round(time.time() - start, 3)
                if result:
                    cls.frontend.add_line_at_table(host=host, port='1723', time=str(end))
                if cls.scan_stop_event.is_set():
                    return cls._stop_pptp_run()
                cls.done_quantity += 1
        cls.scan_stop_event.set()
        return cls._stop_pptp_run()

    @classmethod
    def run(cls) -> None:
        # TODO add csv saving
        cls._queue_worker_thread = threading.Thread(target=cls._queue_save_worker)
        # cls._progress_bar_worker_thread = threading.Thread(
        #     target=cls._progress_bar_worker, args=(int(cls.frontend.quantityLabel.text()), len(cls.ports))
        # )
        cls._queue_worker_thread.start()
        # cls._progress_bar_worker_thread.start()
        for host in cls.ip_networks():
            for port in cls.ports:
                if cls.scan_stop_event.is_set():
                    return cls._stop_run()
                cls.frontend.currentHost_label.setText('Current host: {host}:{port}'.format(host=host, port=port))
                while threading.active_count() >= cls.frontend.threads_spin.value() + cls.threads_orig:
                    time.sleep(cls._delay)
                threading.Thread(target=cls._host_check, args=(host, int(port))).start()
                cls.done_quantity += 1
        cls.scan_stop_event.set()
        return cls._stop_run()
