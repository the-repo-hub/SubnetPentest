import ipaddress
import re
import socket
import threading
import time
from typing import List, Type, Union

from PyQt5.QtWidgets import QMainWindow, QTableWidgetItem

from consts import TableColumnsConsts
from database import HostsDataTable, base_session

# 1. Scan method (Backend.run)
# 2. Queue worker
# 3. Progress bar worker

CUSTOM_WORKERS = 3


class Backend:
    host_pattern = re.compile(r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_range_pattern = re.compile(
        r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)-((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_cidr_pattern = re.compile(
        r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)/([0-9]|[1-2][0-9]|3[0-2])$')
    port_pattern = re.compile(r'^([1-9]\d{0,3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$')

    ip_networks_lines: List[Union[ipaddress.IPv4Network, str]] = []
    ports: List[str] = []

    scan_stop_event = threading.Event()
    threads_orig = threading.active_count()

    frontend = Type[QMainWindow]

    stop_workers = threading.Event()

    base_queue: List[HostsDataTable] = []
    done_quantity = 0

    @classmethod
    def ip_networks(cls):
        for line in cls.ip_networks_lines:
            if isinstance(line, ipaddress.IPv4Network):
                for host in line:
                    yield str(host)
            else:
                yield line

    @classmethod
    def set_ip_networks(cls, network_lines: List[str]):
        quantity = 0
        cls.ip_networks_lines.clear()
        for num, line in enumerate(network_lines, start=1):
            if Backend.host_pattern.match(line):
                quantity += 1
                cls.ip_networks_lines.append(line)
            elif Backend.host_range_pattern.match(line):
                start, end = map(ipaddress.IPv4Address, line.split('-'))
                network = next(ipaddress.summarize_address_range(start, end))
                quantity += network.num_addresses
                cls.ip_networks_lines.append(network)
            elif Backend.host_cidr_pattern.match(line):
                network = ipaddress.ip_network(line, strict=False)
                quantity += network.num_addresses
                cls.ip_networks_lines.append(network)
            else:
                cls.frontend.warning_label.setText(f'Error in line {num}')
                Backend.ip_networks_lines.clear()
                return None
        cls.frontend.quantityLabel.setText(str(quantity))

    @classmethod
    def _queue_save_worker(cls):
        while not cls.stop_workers.is_set():
            time.sleep(5)
            if cls.base_queue:
                length = len(cls.base_queue)
                for i in range(length):
                    cls.base_queue[i].add_or_edit_data_to_base()
                base_session.commit()
                cls.base_queue = cls.base_queue[length:]

    @classmethod
    def _progress_bar_worker(cls):
        all_ips_quantity = int(cls.frontend.quantityLabel.text())
        while not cls.stop_workers.is_set():
            time.sleep(2)
            percent = cls.done_quantity * 100 // (all_ips_quantity * len(cls.ports))
            if percent != int(cls.frontend.progressBar.value()):
                cls.frontend.progressBar.setValue(percent)
        cls.done_quantity = 0

    @classmethod
    def _host_check(cls, host: str, port: int) -> None:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(cls.frontend.timeout_spin.value())
        start = time.time()
        result = sock.connect_ex((host, port))
        end = round(time.time() - start, 3)
        if result == 0:
            cls.frontend.add_line_at_table(host=host, time=str(end), port=str(port))
            cls.base_queue.append(HostsDataTable(host=host, port=port))
        return sock.close()

    @classmethod
    def _stop_run(cls):
        cls.stop_workers.set()
        # we need to wait workers
        while threading.active_count() > cls.threads_orig + CUSTOM_WORKERS:
            cls.frontend.currentHost_label.setText(f'Wait for stop {threading.active_count() - cls.threads_orig} threads')
            time.sleep(0.2)
        # Renew events
        cls.scan_stop_event = threading.Event()
        cls.stop_workers = threading.Event()

        # Enable modules, scans, etc
        cls.frontend.scanBtn.setEnabled(True)
        cls.frontend.pptpBtn.setEnabled(True)
        cls.frontend.set_modules_status(True)

        # Return button functionality
        cls.frontend.scanBtn.clicked.disconnect(cls.frontend.scan_stop)
        cls.frontend.scanBtn.clicked.connect(cls.frontend.scan_start)
        cls.frontend.currentHost_label.setText('Done!')
        cls.frontend.scanBtn.setText('Scan')

    @classmethod
    def run(cls) -> None:
        # TODO check base is busy
        threading.Thread(target=cls._queue_save_worker).start()
        threading.Thread(target=cls._progress_bar_worker).start()
        for host in cls.ip_networks():
            for port in cls.ports:
                if cls.scan_stop_event.is_set():
                    return cls._stop_run()
                cls.frontend.currentHost_label.setText('Current host: {host}:{port}'.format(host=host, port=port))
                while threading.active_count() >= cls.frontend.threads_spin.value() + cls.threads_orig:
                    time.sleep(0.2)
                threading.Thread(target=cls._host_check, args=(host, int(port))).start()
                cls.done_quantity += 1
        return cls._stop_run()
