import re
import socket
import threading
import time
from ipaddress import IPv4Network
from threading import Thread
from typing import List

from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem, QMainWindow


class Backend:
    host_pattern = re.compile(r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_range_pattern = re.compile(r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)-((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_cidr_pattern = re.compile(r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)/([0-9]|[1-2][0-9]|3[0-2])$')
    lines: List[IPv4Network] = []
    ports: List[str] = []
    timeout = 10
    threads = 300
    stop_event = threading.Event()

    @classmethod
    def host_check(cls, host: str, port: int, table: QTableWidget) -> None:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(cls.timeout)
        result = sock.connect_ex((host, port))
        if result == 0:
            current_row = table.rowCount()
            table.insertRow(current_row)
            table.setItem(current_row, 0, QTableWidgetItem(host))
            table.setItem(current_row, 1, QTableWidgetItem(str(port)))
        sock.close()
        return None

    @classmethod
    def run(cls, frontend: QMainWindow) -> None:
        threads_orig = threading.active_count()
        for line in cls.lines:
            for host in line:
                if cls.stop_event.is_set():
                    break
                for port in cls.ports:
                    if cls.stop_event.is_set():
                        break
                    frontend.currentHost.setText('Current host: {host}:{port}'.format(host=host, port=port))
                    while threading.active_count() >= cls.threads + threads_orig:
                        time.sleep(0.1)
                    Thread(target=cls.host_check, args=(str(host), int(port), frontend.tableWidget)).start()
        while threading.active_count() > threads_orig:
            frontend.currentHost.setText(f'Wait for stop {threading.active_count()} threads')
            time.sleep(0.2)
        frontend.currentHost.setText('Done!')
        frontend.scanBtn.clicked.connect(frontend.scan_start)
        frontend.scanBtn.setText('Scan')
        cls.stop_event = threading.Event()
