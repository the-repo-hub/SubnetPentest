import re
import socket
import threading
import time
from ipaddress import IPv4Network
from typing import List, Type

from PyQt5.QtWidgets import QMainWindow, QTableWidgetItem

from database import HostsDataTable, base_session
from consts import TableColumnsConsts

# 1. Scan method (Backend.run)
# 2. Queue worker
# 3. Progress bar worker

CUSTOM_WORKERS = 3


class Backend:
    host_pattern = re.compile(r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_range_pattern = re.compile(
        r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)-((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$')
    host_cidr_pattern = re.compile(
        r'^((25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)/([0-9]|[1-2][0-9]|3[0-2])$')
    port_pattern = re.compile(r'^([1-9]\d{0,3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$')

    ip_networks: List[IPv4Network] = []
    ports: List[str] = []

    scan_stop_event = threading.Event()
    threads_orig = threading.active_count()

    frontend = Type[QMainWindow]

    stop_workers = threading.Event()

    base_queue: List[HostsDataTable] = []
    done_quantity = 0

    @classmethod
    def _queue_save_worker(cls):
        while not cls.stop_workers.is_set():
            time.sleep(5)
            if cls.base_queue:
                length = len(cls.base_queue)
                for i in range(length):
                    cls.base_queue[i].add_or_edit_data_to_base()
                base_session.commit()
                cls.base_queue = cls.base_queue[length:]

    @classmethod
    def _progress_bar_worker(cls):
        all_ips_quantity = int(cls.frontend.quantityLabel.text())
        while not cls.stop_workers.is_set():
            time.sleep(2)
            percent = cls.done_quantity * 100 // (all_ips_quantity * len(cls.ports))
            if percent != int(cls.frontend.progressBar.value()):
                cls.frontend.progressBar.setValue(percent)
        cls.done_quantity = 0

    @classmethod
    def _host_check(cls, host: str, port: int) -> None:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(cls.frontend.timeout_spin.value())
        start = time.time()
        result = sock.connect_ex((host, port))
        end = round(time.time() - start, 3)
        if result == 0:
            current_row = cls.frontend.tableWidget.rowCount()
            cls.frontend.tableWidget.insertRow(current_row)
            cls.frontend.tableWidget.setItem(current_row, TableColumnsConsts.host.value, QTableWidgetItem(host))
            cls.frontend.tableWidget.setItem(current_row, TableColumnsConsts.port.value, QTableWidgetItem(str(port)))
            cls.frontend.tableWidget.setItem(current_row, TableColumnsConsts.time.value, QTableWidgetItem(str(end)))
            cls.base_queue.append(HostsDataTable(host=host, port=port))
        return sock.close()

    @classmethod
    def _stop_run(cls):
        cls.stop_workers.set()
        # we need to wait workers
        while threading.active_count() > cls.threads_orig + CUSTOM_WORKERS:
            cls.frontend.currentHost_label.setText(f'Wait for stop {threading.active_count() - cls.threads_orig} threads')
            time.sleep(0.2)
        # Renew events
        cls.scan_stop_event = threading.Event()
        cls.stop_workers = threading.Event()

        # Enable modules, scans, etc
        cls.frontend.scanBtn.setEnabled(True)
        cls.frontend.pptpBtn.setEnabled(True)
        cls.frontend.set_modules_status(True)

        # Return button functionality
        cls.frontend.scanBtn.clicked.disconnect(cls.frontend.scan_stop)
        cls.frontend.scanBtn.clicked.connect(cls.frontend.scan_start)
        cls.frontend.currentHost_label.setText('Done!')
        cls.frontend.scanBtn.setText('Scan')

    @classmethod
    def run(cls) -> None:
        # TODO check base is busy
        threading.Thread(target=cls._queue_save_worker).start()
        threading.Thread(target=cls._progress_bar_worker).start()
        for network in cls.ip_networks:
            for host in network:
                for port in cls.ports:
                    if cls.scan_stop_event.is_set():
                        return cls._stop_run()
                    cls.frontend.currentHost_label.setText('Current host: {host}:{port}'.format(host=host, port=port))
                    while threading.active_count() >= cls.frontend.threads_spin.value() + cls.threads_orig:
                        time.sleep(0.2)
                    threading.Thread(target=cls._host_check, args=(str(host), int(port))).start()
                    cls.done_quantity += 1
        return cls._stop_run()
